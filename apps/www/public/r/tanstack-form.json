{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tanstack-form",
  "type": "registry:ui",
  "title": "TanStack Form",
  "description": "A complete form management solution using TanStack Form with Zod validation, supporting all input types including arrays and nested objects.",
  "dependencies": [
    "@tanstack/react-form",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "checkbox",
    "field",
    "input",
    "select",
    "textarea"
  ],
  "files": [
    {
      "path": "components/ui/tanstack-form.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport {\n  createFormHook,\n  createFormHookContexts,\n  useStore,\n} from \"@tanstack/react-form\"\nimport type { z } from \"zod\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport {\n  Field,\n  FieldContent,\n  FieldDescription,\n  FieldError,\n  FieldGroup,\n  FieldLabel,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldTitle,\n} from \"@/components/ui/field\"\nimport { Input } from \"@/components/ui/input\"\nimport { Select } from \"@/components/ui/select\"\nimport { Textarea } from \"@/components/ui/textarea\"\n\nexport const { fieldContext, useFieldContext, formContext, useFormContext } =\n  createFormHookContexts()\n\nexport const { useAppForm } = createFormHook({\n  fieldComponents: {\n    Input: FormInput,\n    Select: FormSelect,\n    Textarea: FormTextarea,\n    Checkbox: FormCheckbox,\n  },\n  formComponents: {\n    SubmitButton: SubmitButton,\n  },\n  fieldContext,\n  formContext,\n})\n\nexport function SubmitButton(props: React.ComponentProps<typeof Button>) {\n  const form = useFormContext()\n  return (\n    <form.Subscribe selector={(state) => state.isSubmitting}>\n      {(isSubmitting) => (\n        <Button type=\"submit\" disabled={isSubmitting} {...props} />\n      )}\n    </form.Subscribe>\n  )\n}\n\nfunction FormInput(props: React.ComponentProps<typeof Input>) {\n  const field = useFieldContext<string>()\n\n  return (\n    <Input\n      name={field.name}\n      value={field.state.value}\n      placeholder={props.placeholder}\n      onBlur={field.handleBlur}\n      onChange={(e) => field.handleChange(e.target.value)}\n      {...props}\n    />\n  )\n}\n\nfunction FormSelect(props: React.ComponentProps<typeof Select>) {\n  const field = useFieldContext<string>()\n  return (\n    <Select\n      name={field.name}\n      value={field.state.value}\n      onValueChange={(value) => field.handleChange(value)}\n      {...props}\n    />\n  )\n}\n\nfunction FormTextarea(props: React.ComponentProps<typeof Textarea>) {\n  const field = useFieldContext<string>()\n  return (\n    <Textarea\n      name={field.name}\n      value={field.state.value}\n      placeholder={props.placeholder}\n      onBlur={field.handleBlur}\n      onChange={(e) => field.handleChange(e.target.value)}\n      {...props}\n    />\n  )\n}\n\nfunction FormCheckbox(props: React.ComponentProps<typeof Checkbox>) {\n  const field = useFieldContext<boolean>()\n  return (\n    <Checkbox\n      name={field.name}\n      checked={Boolean(field.state.value)}\n      onCheckedChange={(checked) => field.handleChange(Boolean(checked))}\n      {...props}\n    />\n  )\n}\n\n/**\n * Type helper to extract all possible deep keys from an object type\n * Supports nested objects and arrays with index access\n * Based on TanStack Form's DeepKeys implementation\n *\n * @example\n * type User = { name: string; emails: { address: string }[] }\n * type Keys = DeepKeys<User>\n * // \"name\" | \"emails\" | \"emails.0\" | \"emails.0.address\" | \"emails[0]\" | \"emails[0].address\"\n */\nexport type DeepKeys<T> = T extends object\n  ? {\n      [K in keyof T & (string | number)]: T[K] extends any[]\n        ?\n            | `${K}`\n            | `${K}.${number}`\n            | `${K}.${number}.${DeepKeys<T[K][number]> & string}`\n            | `${K}[${number}]`\n            | `${K}[${number}].${DeepKeys<T[K][number]> & string}`\n        : T[K] extends object\n          ? `${K}` | `${K}.${DeepKeys<T[K]> & string}`\n          : `${K}`\n    }[keyof T & (string | number)]\n  : never\n\n/**\n * Type for TanStack Form API with generic form data\n * Uses a branded type approach to preserve type information through the wrapper\n */\nexport type FormApi<TFormData = any> = {\n  __brand: \"FormApi\"\n  __formData: TFormData\n} & Record<string, any>\n\n/**\n * Helper type to extract form data type from FormApi\n */\ntype InferFormData<T> = T extends { __formData: infer U } ? U : any\n\n/**\n * Helper type to extract the value type at a given path\n * Based on TanStack Form's DeepValue implementation\n */\ntype DeepValue<TData, TPath> = TPath extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof TData\n    ? DeepValue<TData[Key], Rest>\n    : never\n  : TPath extends `${infer Key}[${number}]`\n    ? Key extends keyof TData\n      ? TData[Key] extends (infer Item)[]\n        ? Item\n        : never\n      : never\n    : TPath extends `${infer Key}[${number}].${infer Rest}`\n      ? Key extends keyof TData\n        ? TData[Key] extends (infer Item)[]\n          ? DeepValue<Item, Rest>\n          : never\n        : never\n      : TPath extends keyof TData\n        ? TData[TPath]\n        : never\n\n/**\n * Simplified Field API type with essential properties\n * This is a typed version of TanStack Form's FieldApi with the most commonly used properties\n */\nexport type FieldApiType<TValue = any> = {\n  name: string\n  state: {\n    value: TValue\n    meta: {\n      isTouched: boolean\n      isDirty: boolean\n      isValidating: boolean\n      errors: (string | { message?: string })[]\n    }\n  }\n  handleChange: (value: TValue) => void\n  handleBlur: () => void\n  pushValue?: (value: any) => void\n  removeValue?: (index: number) => void\n}\n\n/**\n * Hook to create a TanStack form with Zod validation\n * Returns a type-safe FormApi with inferred form data type\n *\n * @example\n * const form = useForm({\n *   schema: z.object({ email: z.string().email() }),\n *   defaultValues: { email: '' },\n *   onSubmit: async (values) => console.log(values),\n * })\n * // form is typed as FormApi<{ email: string }>\n */\nexport function useForm<TSchema extends z.ZodType>({\n  schema,\n  defaultValues,\n  onSubmit,\n  validationMode = \"onBlur\",\n}: {\n  schema: TSchema\n  defaultValues: z.infer<TSchema>\n  onSubmit: (values: z.infer<TSchema>) => void | Promise<void>\n  validationMode?: \"onChange\" | \"onBlur\" | \"onSubmit\"\n}) {\n  return useAppForm({\n    defaultValues,\n    validators: {\n      [validationMode]: schema,\n    },\n    onSubmit: async ({ value }) => {\n      await onSubmit(value as z.infer<TSchema>)\n    },\n  })\n}\n\n/**\n * Form wrapper component that provides form context and handles submission\n *\n * @example\n * <Form form={form}>\n *   <FormField form={form} name=\"email\">\n *     {(field) => (\n *       <FormItem field={field}>\n *         <FormLabel>Email</FormLabel>\n *         <FormControl>\n *           <Input\n *             value={field.state.value}\n *             onChange={(e) => field.handleChange(e.target.value)}\n *             onBlur={field.handleBlur}\n *           />\n *         </FormControl>\n *         <FormMessage />\n *       </FormItem>\n *     )}\n *   </FormField>\n * </Form>\n */\nexport function Form({\n  children,\n  ...props\n}: {\n  children: React.ReactNode\n  className?: string\n} & Omit<React.ComponentProps<\"form\">, \"onSubmit\">) {\n  const formContext = useFormContext()\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault()\n        e.stopPropagation()\n        formContext.handleSubmit()\n      }}\n      {...props}\n    >\n      {children}\n    </form>\n  )\n}\n\nexport function FormLabel(props: React.ComponentProps<typeof FieldLabel>) {\n  const field = useFieldContext<string>()\n  return <FieldLabel htmlFor={field.name} {...props} />\n}\n\n/**\n * Description text for form field - uses FieldDescription with TanStack Form integration\n */\nexport function FormDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof FieldDescription>) {\n  const field = useFieldContext<string>()\n\n  return (\n    <FieldDescription\n      id={`${field.name}-form-item-description`}\n      className={className}\n      {...props}\n    />\n  )\n}\n\n/**\n * Error message for form field - uses FieldError with TanStack Form integration\n */\nexport function FormMessage({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof FieldError>) {\n  const field = useFieldContext()\n  const errors = useStore(field.store, (state) => state.meta.errors)\n  const hasSubmitted = field.form.state.submissionAttempts > 0\n  const shouldShowError =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  if (!shouldShowError && !children) {\n    return null\n  }\n\n  return (\n    <FieldError\n      id={`${field.name}-form-item-message`}\n      errors={errors}\n      className={className}\n      {...props}\n    >\n      {errors.map((error) => (\n        <div\n          key={typeof error === \"string\" ? error : error.message}\n          className=\"mt-1 font-bold text-red-500\"\n        >\n          {typeof error === \"string\" ? error : error.message}\n        </div>\n      ))}\n    </FieldError>\n  )\n}\n\n/**\n * Re-export Field components for direct use in custom layouts\n * These can be used when you need more control over the form layout\n * and don't need the TanStack Form context integration\n *\n * @example\n * // Direct usage without context\n * <FormField form={form} name=\"email\">\n *   {(field) => {\n *     const { isInvalid } = getFieldState(field, form)\n *     return (\n *       <Field data-invalid={isInvalid} orientation=\"horizontal\">\n *         <FieldLabel htmlFor=\"email\">Email</FieldLabel>\n *         <FieldContent>\n *           <Input {...getInputFieldProps(field)} id=\"email\" />\n *           <FieldDescription>Enter your email address</FieldDescription>\n *           <FieldError errors={field.state.meta.errors} />\n *         </FieldContent>\n *       </Field>\n *     )\n   }}\n * </FormField>\n */\nexport {\n  Field,\n  FieldContent,\n  FieldGroup,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldTitle,\n}\n",
      "type": "registry:ui"
    }
  ]
}