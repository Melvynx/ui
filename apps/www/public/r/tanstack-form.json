{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tanstack-form",
  "type": "registry:ui",
  "title": "TanStack Form",
  "description": "A complete form management solution using TanStack Form with Zod validation, supporting all input types including arrays and nested objects.",
  "dependencies": [
    "@tanstack/react-form",
    "zod"
  ],
  "registryDependencies": [
    "label"
  ],
  "files": [
    {
      "path": "components/ui/tanstack-form.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\"\n\nimport * as React from \"react\"\nimport { Label } from \"@radix-ui/react-label\"\nimport { useForm as useTanstackFormBase } from \"@tanstack/react-form\"\nimport type { z } from \"zod\"\n\nimport { cn } from \"@/lib/utils\"\n\n/**\n * Type helper to extract all possible deep keys from an object type\n * Supports nested objects and arrays with index access\n * Based on TanStack Form's DeepKeys implementation\n *\n * @example\n * type User = { name: string; emails: { address: string }[] }\n * type Keys = DeepKeys<User>\n * // \"name\" | \"emails\" | \"emails.0\" | \"emails.0.address\" | \"emails[0]\" | \"emails[0].address\"\n */\nexport type DeepKeys<T> = T extends object\n  ? {\n      [K in keyof T & (string | number)]: T[K] extends any[]\n        ?\n            | `${K}`\n            | `${K}.${number}`\n            | `${K}.${number}.${DeepKeys<T[K][number]> & string}`\n            | `${K}[${number}]`\n            | `${K}[${number}].${DeepKeys<T[K][number]> & string}`\n        : T[K] extends object\n          ? `${K}` | `${K}.${DeepKeys<T[K]> & string}`\n          : `${K}`\n    }[keyof T & (string | number)]\n  : never\n\n/**\n * Type for TanStack Form API with generic form data\n * Uses a branded type approach to preserve type information through the wrapper\n */\nexport type FormApi<TFormData = any> = {\n  __brand: \"FormApi\"\n  __formData: TFormData\n} & Record<string, any>\n\n/**\n * Helper type to extract form data type from FormApi\n */\ntype InferFormData<T> = T extends { __formData: infer U } ? U : any\n\n/**\n * Helper type to extract the value type at a given path\n * Based on TanStack Form's DeepValue implementation\n */\ntype DeepValue<TData, TPath> = TPath extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof TData\n    ? DeepValue<TData[Key], Rest>\n    : never\n  : TPath extends `${infer Key}[${number}]`\n    ? Key extends keyof TData\n      ? TData[Key] extends (infer Item)[]\n        ? Item\n        : never\n      : never\n    : TPath extends `${infer Key}[${number}].${infer Rest}`\n      ? Key extends keyof TData\n        ? TData[Key] extends (infer Item)[]\n          ? DeepValue<Item, Rest>\n          : never\n        : never\n      : TPath extends keyof TData\n        ? TData[TPath]\n        : never\n\n/**\n * Simplified Field API type with essential properties\n * This is a typed version of TanStack Form's FieldApi with the most commonly used properties\n */\nexport type FieldApiType<TValue = any> = {\n  name: string\n  state: {\n    value: TValue\n    meta: {\n      isTouched: boolean\n      isDirty: boolean\n      isValidating: boolean\n      errors: (string | { message?: string })[]\n    }\n  }\n  handleChange: (value: TValue) => void\n  handleBlur: () => void\n  pushValue?: (value: any) => void\n  removeValue?: (index: number) => void\n}\n\n/**\n * Hook to create a TanStack form with Zod validation\n * Returns a type-safe FormApi with inferred form data type\n *\n * @example\n * const form = useForm({\n *   schema: z.object({ email: z.string().email() }),\n *   defaultValues: { email: '' },\n *   onSubmit: async (values) => console.log(values),\n * })\n * // form is typed as FormApi<{ email: string }>\n */\nexport function useForm<TSchema extends z.ZodType>({\n  schema,\n  defaultValues,\n  onSubmit,\n  validationMode = \"onBlur\",\n}: {\n  schema: TSchema\n  defaultValues: z.infer<TSchema>\n  onSubmit: (values: z.infer<TSchema>) => void | Promise<void>\n  validationMode?: \"onChange\" | \"onBlur\" | \"onSubmit\"\n}): FormApi<z.infer<TSchema>> {\n  return useTanstackFormBase({\n    defaultValues,\n    validators: {\n      [validationMode]: schema,\n    },\n    onSubmit: async ({ value }) => {\n      await onSubmit(value as z.infer<TSchema>)\n    },\n  }) as unknown as FormApi<z.infer<TSchema>>\n}\n\n/**\n * Form wrapper component that provides form context and handles submission\n *\n * @example\n * <Form form={form}>\n *   <FormField form={form} name=\"email\">\n *     {(field) => (\n *       <FormItem field={field}>\n *         <FormLabel>Email</FormLabel>\n *         <FormControl>\n *           <Input\n *             value={field.state.value}\n *             onChange={(e) => field.handleChange(e.target.value)}\n *             onBlur={field.handleBlur}\n *           />\n *         </FormControl>\n *         <FormMessage />\n *       </FormItem>\n *     )}\n *   </FormField>\n * </Form>\n */\nexport function Form({\n  form,\n  children,\n  className,\n  disabled,\n  ...props\n}: {\n  form: FormApi\n  children: React.ReactNode\n  className?: string\n  disabled?: boolean\n} & Omit<React.ComponentProps<\"form\">, \"onSubmit\">) {\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault()\n        void form.handleSubmit()\n      }}\n      className={className}\n      {...props}\n    >\n      <fieldset\n        disabled={disabled ?? form.state.isSubmitting}\n        className={className}\n      >\n        {children}\n      </fieldset>\n    </form>\n  )\n}\n\n/**\n * Field wrapper component that connects to form and provides field API\n * Automatically infers form data type from the form parameter for type-safe field names!\n *\n * @example\n * const form = useForm({ schema: z.object({ email: z.string(), teamName: z.string() }), ... })\n *\n * <FormField form={form} name=\"email\"> // ✅ Valid - type automatically inferred!\n * <FormField form={form} name=\"teamName\"> // ✅ Valid - autocomplete works!\n * <FormField form={form} name=\"teamNam\"> // ❌ TypeScript error - typo caught at compile time!\n *\n * @example\n * // With arrays\n * const form = useForm({ schema: z.object({ users: z.array(z.object({ email: z.string() })) }), ... })\n * <FormField form={form} name=\"users\"> // ✅ Valid\n * <FormField form={form} name=\"users[0].email\"> // ✅ Valid - supports nested paths!\n */\nexport function FormField<\n  TForm extends FormApi,\n  TName extends DeepKeys<InferFormData<TForm>> = DeepKeys<InferFormData<TForm>>,\n>({\n  form,\n  name,\n  mode,\n  children,\n}: {\n  form: TForm\n  name: TName\n  mode?: \"value\" | \"array\"\n  children: (\n    field: FieldApiType<DeepValue<InferFormData<TForm>, TName>>\n  ) => React.ReactNode\n}) {\n  const FormFieldComponent = (form as any).Field\n  return (\n    <FormFieldComponent name={name} mode={mode}>\n      {children}\n    </FormFieldComponent>\n  )\n}\n\ntype FormItemContextValue = {\n  field: any\n  form: FormApi\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue | null>(null)\n\nconst useFormItem = () => {\n  const context = React.useContext(FormItemContext)\n\n  if (!context) {\n    throw new Error(\"FormItem components must be used within FormItem\")\n  }\n\n  return context\n}\n\n/**\n * Container for form field with error state and accessibility\n *\n * @example\n * <FormItem field={field} form={form}>\n *   <FormLabel>Email</FormLabel>\n *   <FormControl>\n *     <Input {...getInputFieldProps(field)} />\n *   </FormControl>\n *   <FormDescription>Enter your email</FormDescription>\n *   <FormMessage />\n * </FormItem>\n */\nexport function FormItem({\n  field,\n  form,\n  className,\n  children,\n  ...props\n}: {\n  field: any\n  form: FormApi\n  children: React.ReactNode\n  className?: string\n} & React.ComponentProps<\"div\">) {\n  const id = React.useId()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  return (\n    <FormItemContext.Provider value={{ field, form, id }}>\n      <div\n        data-slot=\"form-item\"\n        data-invalid={isInvalid}\n        className={cn(\"grid gap-2\", className)}\n        {...props}\n      >\n        {children}\n      </div>\n    </FormItemContext.Provider>\n  )\n}\n\n/**\n * Label for form field\n */\nexport function FormLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof Label>) {\n  const { field, form, id } = useFormItem()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  return (\n    <Label\n      data-slot=\"form-label\"\n      data-error={!!isInvalid}\n      className={cn(\"data-[error=true]:text-destructive\", className)}\n      htmlFor={`${id}-form-item`}\n      {...props}\n    />\n  )\n}\n\n/**\n * Control wrapper for form field input\n * Simply passes through children - field props should be spread directly on inputs\n */\nexport function FormControl({ children }: { children: React.ReactNode }) {\n  return <>{children}</>\n}\n\n/**\n * Description text for form field\n */\nexport function FormDescription({\n  className,\n  ...props\n}: React.ComponentProps<\"p\">) {\n  const { id } = useFormItem()\n\n  return (\n    <p\n      data-slot=\"form-description\"\n      id={`${id}-form-item-description`}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\n/**\n * Error message for form field\n */\nexport function FormMessage({\n  className,\n  ...props\n}: React.ComponentProps<\"p\">) {\n  const { field, form, id } = useFormItem()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const shouldShowError =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  if (!shouldShowError && !props.children) {\n    return null\n  }\n\n  const error = shouldShowError ? field.state.meta.errors?.[0] : null\n\n  // Handle both string errors and Zod error objects\n  const body = error\n    ? typeof error === \"string\"\n      ? error\n      : (error?.message ?? JSON.stringify(error))\n    : props.children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      data-slot=\"form-message\"\n      id={`${id}-form-item-message`}\n      className={cn(\"text-destructive text-sm\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n}\n\n/**\n * Helper to get field state (isInvalid, errors, etc.)\n *\n * @example\n * const { isInvalid, errors } = getFieldState(field, form)\n */\nexport function getFieldState(field: any, form?: FormApi) {\n  const hasSubmitted = form ? form.state.submissionAttempts > 0 : false\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n  return {\n    isInvalid,\n    errors: field.state.meta.errors,\n    isTouched: field.state.meta.isTouched,\n    isDirty: field.state.meta.isDirty,\n    isValidating: field.state.meta.isValidating,\n  }\n}\n\n/**\n * Helper to get field props for native input elements (input, textarea)\n *\n * @example\n * <Input {...getInputFieldProps(field)} type=\"email\" />\n */\nexport function getInputFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value ?? \"\",\n    onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>\n      field.handleChange(e.target.value),\n    onBlur: field.handleBlur,\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for controlled components (Select)\n *\n * @example\n * <Select {...getControlledFieldProps(field)}>\n *   <SelectTrigger><SelectValue /></SelectTrigger>\n *   <SelectContent>...</SelectContent>\n * </Select>\n */\nexport function getControlledFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value,\n    onValueChange: (value: string) => field.handleChange(value),\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for checkbox components\n *\n * @example\n * <Checkbox {...getCheckboxFieldProps(field)} />\n */\nexport function getCheckboxFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    checked: field.state.value,\n    onCheckedChange: (checked: boolean) => {\n      field.handleChange(checked)\n      // Trigger blur to validate immediately after change\n      field.handleBlur()\n    },\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for switch components\n *\n * @example\n * <Switch {...getSwitchFieldProps(field)} />\n */\nexport function getSwitchFieldProps(field: any) {\n  return getCheckboxFieldProps(field)\n}\n\n/**\n * Helper to get field props for textarea elements\n * Alias for getInputFieldProps since they share the same signature\n *\n * @example\n * <Textarea {...getTextareaFieldProps(field)} />\n */\nexport function getTextareaFieldProps(field: any) {\n  return getInputFieldProps(field)\n}\n\n/**\n * Helper to get field props for Select components\n * Alias for getControlledFieldProps with better naming for selects\n *\n * @example\n * <Select {...getSelectFieldProps(field)}>\n *   <SelectTrigger><SelectValue /></SelectTrigger>\n *   <SelectContent>...</SelectContent>\n * </Select>\n */\nexport function getSelectFieldProps(field: any) {\n  return getControlledFieldProps(field)\n}\n\n/**\n * Helper to get field props for RadioGroup components\n *\n * @example\n * <RadioGroup {...getRadioGroupFieldProps(field)}>\n *   <RadioGroupItem value=\"option1\" />\n *   <RadioGroupItem value=\"option2\" />\n * </RadioGroup>\n */\nexport function getRadioGroupFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value,\n    onValueChange: (value: string) => {\n      field.handleChange(value)\n      // Trigger blur to validate immediately after change\n      field.handleBlur()\n    },\n    \"aria-invalid\": isInvalid,\n  }\n}\n",
      "type": "registry:ui"
    }
  ]
}