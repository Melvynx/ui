{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "all",
  "type": "registry:ui",
  "description": "All UI components from Now.ts UI",
  "dependencies": [
    "@hookform/resolvers",
    "@tanstack/react-form",
    "class-variance-authority",
    "lucide-react",
    "motion",
    "react-hook-form",
    "zod",
    "zustand"
  ],
  "registryDependencies": [
    "button",
    "form",
    "https://ui.nowts.app/r/spinner.json",
    "label"
  ],
  "files": [
    {
      "path": "components/ui/submit-button.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport type { ComponentProps } from \"react\"\nimport { motion } from \"motion/react\"\nimport { useFormStatus } from \"react-dom\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\nimport { Spinner } from \"./spinner\"\n\nexport const SubmitButton = (props: ComponentProps<typeof Button>) => {\n  const { pending } = useFormStatus()\n\n  return (\n    <LoadingButton loading={pending} {...props}>\n      {props.children}\n    </LoadingButton>\n  )\n}\n\nexport const LoadingButton = ({\n  loading,\n  children,\n  className,\n  ...props\n}: ComponentProps<typeof Button> & {\n  loading?: boolean\n  success?: string\n}) => {\n  return (\n    <Button {...props} className={cn(className, \"relative\")}>\n      <motion.span\n        className=\"flex items-center gap-1\"\n        animate={{\n          opacity: loading ? 0 : 1,\n          y: loading ? -10 : 0,\n        }}\n      >\n        {children}\n      </motion.span>\n      <motion.span\n        initial={{\n          opacity: 0,\n          y: 10,\n        }}\n        animate={{\n          opacity: loading ? 1 : 0,\n          y: loading ? 0 : 10,\n        }}\n        exit={{\n          opacity: 0,\n          y: 10,\n        }}\n        className=\"absolute inset-0 flex items-center justify-center\"\n      >\n        <Spinner size={20} />\n      </motion.span>\n    </Button>\n  )\n}\n"
    },
    {
      "path": "components/ui/spinner.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "import type { LucideProps } from \"lucide-react\"\nimport { Loader2 } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport const Spinner = ({ className, ...props }: LucideProps) => {\n  return <Loader2 {...props} className={cn(className, \"animate-spin\")} />\n}\n"
    },
    {
      "path": "components/ui/next-top-loader.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { createPortal } from \"react-dom\"\nimport { create } from \"zustand\"\n\ntype NextTopLoaderProps = {\n  /**\n   * Color for the TopLoader.\n   * @default \"#3b82f6\"\n   */\n  color?: string\n  /**\n   * The height for the TopLoader in pixels (px).\n   * @default 3\n   */\n  height?: number\n  /**\n   * To show spinner or not.\n   * @default true\n   */\n  showSpinner?: boolean\n  /**\n   * Animation speed in ms for the TopLoader.\n   * @default 200\n   */\n  speed?: number\n  /**\n   * Timeout in ms before the TopLoader will appear.\n   * @default 0\n   */\n  delay?: number\n}\n\nconst isAnchorOfCurrentUrl = (currentUrl: string, newUrl: string) => {\n  const currentUrlObj = new URL(currentUrl)\n  const newUrlObj = new URL(newUrl)\n  const currentHash = currentUrlObj.hash\n  const newHash = newUrlObj.hash\n\n  return (\n    currentUrlObj.hostname === newUrlObj.hostname &&\n    currentUrlObj.pathname === newUrlObj.pathname &&\n    currentUrlObj.search === newUrlObj.search &&\n    currentHash !== newHash &&\n    currentUrlObj.href.replace(currentHash, \"\") ===\n      newUrlObj.href.replace(newHash, \"\")\n  )\n}\n\nexport const useNextTopLoaderStore = create<{\n  isEnable: boolean\n  isLoading: boolean\n  progress: number\n  disable: () => void\n  enable: () => void\n  start: () => void\n  done: () => void\n  setProgress: (progress: number) => void\n}>((set) => ({\n  isEnable: true,\n  isLoading: false,\n  progress: 0,\n  disable: () => set({ isEnable: false }),\n  enable: () => set({ isEnable: true }),\n  start: () => set({ isLoading: true, progress: 0 }),\n  done: () => set({ isLoading: false, progress: 100 }),\n  setProgress: (progress: number) => set({ progress }),\n}))\n\nconst TopLoaderBar = ({\n  color = \"#3b82f6\",\n  height = 3,\n  showSpinner = true,\n  speed = 200,\n}: Pick<NextTopLoaderProps, \"color\" | \"height\" | \"showSpinner\" | \"speed\">) => {\n  const { isLoading, progress } = useNextTopLoaderStore()\n\n  if (!isLoading) return null\n\n  return (\n    <div\n      className=\"pointer-events-none fixed top-0 left-0 z-[9999]\"\n      style={{\n        width: \"100%\",\n        height: `${height}px`,\n      }}\n    >\n      <div\n        className=\"h-full transition-all ease-out\"\n        style={{\n          backgroundColor: color,\n          width: `${progress}%`,\n          transition: `width ${speed}ms ease-out`,\n          boxShadow: `0 0 10px ${color}, 0 0 5px ${color}`,\n        }}\n      />\n      {showSpinner && (\n        <div\n          className=\"absolute top-1/2 right-4 -translate-y-1/2 animate-spin\"\n          style={{\n            width: `${height * 6}px`,\n            height: `${height * 6}px`,\n            border: `2px solid transparent`,\n            borderTop: `2px solid ${color}`,\n            borderRadius: \"50%\",\n          }}\n        />\n      )}\n    </div>\n  )\n}\n\nexport const NextTopLoader = ({\n  color = \"var(--primary)\",\n  height = 2,\n  showSpinner = true,\n  speed = 200,\n  delay = 0,\n}: NextTopLoaderProps) => {\n  const [mounted, setMounted] = React.useState(false)\n\n  React.useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  React.useEffect(() => {\n    let progressInterval: NodeJS.Timeout\n    let startTimeout: NodeJS.Timeout\n\n    const { start, done, setProgress } = useNextTopLoaderStore.getState()\n\n    const startProgress = () => {\n      start()\n      let currentProgress = 0\n\n      progressInterval = setInterval(() => {\n        currentProgress += Math.random() * 15\n        if (currentProgress >= 90) {\n          currentProgress = 90\n          clearInterval(progressInterval)\n        }\n        setProgress(currentProgress)\n      }, 100)\n    }\n\n    const completeProgress = () => {\n      clearInterval(progressInterval)\n      clearTimeout(startTimeout)\n      setProgress(100)\n      setTimeout(() => {\n        done()\n      }, speed)\n    }\n\n    const handleClick = (event: MouseEvent) => {\n      if (useNextTopLoaderStore.getState().isEnable === false) return\n\n      if (event.ctrlKey || event.metaKey) return\n\n      try {\n        const target = event.target as HTMLElement\n        const anchor = target.closest(\"a\")\n\n        if (!anchor) return\n\n        const currentUrl = window.location.href\n        const newUrl = anchor.href\n        const isExternalLink = anchor.target === \"_blank\"\n        const isAnchor = isAnchorOfCurrentUrl(currentUrl, newUrl)\n        const isDisabled = anchor.getAttribute(\"data-toploader-disabled\")\n\n        if (isDisabled === \"true\") return\n\n        if (newUrl === currentUrl || isAnchor || isExternalLink) {\n          // Quick progress for same page or anchor links\n          start()\n          setTimeout(completeProgress, 50)\n        } else {\n          // Start progress for navigation\n          if (delay === 0) {\n            startProgress()\n          } else {\n            startTimeout = setTimeout(() => {\n              startProgress()\n            }, delay)\n          }\n        }\n      } catch {\n        // Quick progress for any errors\n        start()\n        setTimeout(completeProgress, 50)\n      }\n    }\n\n    // Override history methods to detect navigation completion\n    const originalPushState = window.history.pushState\n    const originalReplaceState = window.history.replaceState\n\n    window.history.pushState = function (...args) {\n      completeProgress()\n      return originalPushState.apply(window.history, args)\n    }\n\n    window.history.replaceState = function (...args) {\n      completeProgress()\n      return originalReplaceState.apply(window.history, args)\n    }\n\n    // Listen for popstate (back/forward buttons)\n    const handlePopState = () => {\n      completeProgress()\n    }\n\n    document.addEventListener(\"click\", handleClick)\n    window.addEventListener(\"popstate\", handlePopState)\n\n    return () => {\n      document.removeEventListener(\"click\", handleClick)\n      window.removeEventListener(\"popstate\", handlePopState)\n      clearInterval(progressInterval)\n      clearTimeout(startTimeout)\n\n      // Restore original methods\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n    }\n  }, [delay, speed])\n\n  if (!mounted) return null\n\n  return createPortal(\n    <TopLoaderBar\n      color={color}\n      height={height}\n      showSpinner={showSpinner}\n      speed={speed}\n    />,\n    document.body\n  )\n}\n\n/**\n * Stop loading of the current top loader bar\n */\nexport const stopLoading = () => {\n  const { setProgress, done } = useNextTopLoaderStore.getState()\n  setProgress(100)\n  setTimeout(() => {\n    done()\n  }, 100)\n}\n"
    },
    {
      "path": "components/ui/extended-form.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "\"use client\"\n\nimport type * as React from \"react\"\nimport { zodResolver } from \"@hookform/resolvers/zod\"\nimport type {\n  SubmitHandler,\n  UseFormProps,\n  UseFormReturn,\n} from \"react-hook-form\"\nimport { FormProvider, useForm, type FieldValues } from \"react-hook-form\"\nimport type * as z from \"zod\"\n\nexport type FormProps<T extends FieldValues> = Omit<\n  React.ComponentProps<\"form\">,\n  \"onSubmit\"\n> & {\n  form: UseFormReturn<T>\n  onSubmit: SubmitHandler<T>\n  disabled?: boolean\n}\n\nexport const ExtendedForm = <T extends FieldValues>({\n  form,\n  onSubmit,\n  children,\n  className,\n  disabled,\n  ...props\n}: FormProps<T>) => {\n  return (\n    <FormProvider {...form}>\n      <form\n        onSubmit={form.handleSubmit(onSubmit)}\n        {...props}\n        className={className}\n      >\n        <fieldset\n          disabled={disabled ?? form.formState.isSubmitting}\n          className={className}\n        >\n          {children}\n        </fieldset>\n      </form>\n    </FormProvider>\n  )\n}\n\ntype UseZodFormProps<\n  Input extends FieldValues,\n  Output extends FieldValues,\n  Z extends z.ZodType<Output, Input>,\n> = Exclude<UseFormProps<z.output<Z>>, \"resolver\"> & {\n  schema: Z\n}\n\nexport const useZodForm = <\n  Input extends FieldValues,\n  Output extends FieldValues,\n  Z extends z.ZodType<Output, Input>,\n>({\n  schema,\n  ...formProps\n}: UseZodFormProps<Input, Output, Z>) =>\n  useForm({\n    ...formProps,\n    resolver: zodResolver(schema) as never,\n  })\n"
    },
    {
      "path": "components/ui/tanstack-form.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\"\n\nimport * as React from \"react\"\nimport { useForm as useTanstackFormBase } from \"@tanstack/react-form\"\nimport type { z } from \"zod\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Field,\n  FieldContent,\n  FieldDescription as BaseFieldDescription,\n  FieldError as BaseFieldError,\n  FieldGroup,\n  FieldLabel as BaseFieldLabel,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldTitle,\n} from \"@/components/ui/field\"\n\n/**\n * Type helper to extract all possible deep keys from an object type\n * Supports nested objects and arrays with index access\n * Based on TanStack Form's DeepKeys implementation\n *\n * @example\n * type User = { name: string; emails: { address: string }[] }\n * type Keys = DeepKeys<User>\n * // \"name\" | \"emails\" | \"emails.0\" | \"emails.0.address\" | \"emails[0]\" | \"emails[0].address\"\n */\nexport type DeepKeys<T> = T extends object\n  ? {\n      [K in keyof T & (string | number)]: T[K] extends any[]\n        ?\n            | `${K}`\n            | `${K}.${number}`\n            | `${K}.${number}.${DeepKeys<T[K][number]> & string}`\n            | `${K}[${number}]`\n            | `${K}[${number}].${DeepKeys<T[K][number]> & string}`\n        : T[K] extends object\n          ? `${K}` | `${K}.${DeepKeys<T[K]> & string}`\n          : `${K}`\n    }[keyof T & (string | number)]\n  : never\n\n/**\n * Type for TanStack Form API with generic form data\n * Uses a branded type approach to preserve type information through the wrapper\n */\nexport type FormApi<TFormData = any> = {\n  __brand: \"FormApi\"\n  __formData: TFormData\n} & Record<string, any>\n\n/**\n * Helper type to extract form data type from FormApi\n */\ntype InferFormData<T> = T extends { __formData: infer U } ? U : any\n\n/**\n * Helper type to extract the value type at a given path\n * Based on TanStack Form's DeepValue implementation\n */\ntype DeepValue<TData, TPath> = TPath extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof TData\n    ? DeepValue<TData[Key], Rest>\n    : never\n  : TPath extends `${infer Key}[${number}]`\n    ? Key extends keyof TData\n      ? TData[Key] extends (infer Item)[]\n        ? Item\n        : never\n      : never\n    : TPath extends `${infer Key}[${number}].${infer Rest}`\n      ? Key extends keyof TData\n        ? TData[Key] extends (infer Item)[]\n          ? DeepValue<Item, Rest>\n          : never\n        : never\n      : TPath extends keyof TData\n        ? TData[TPath]\n        : never\n\n/**\n * Simplified Field API type with essential properties\n * This is a typed version of TanStack Form's FieldApi with the most commonly used properties\n */\nexport type FieldApiType<TValue = any> = {\n  name: string\n  state: {\n    value: TValue\n    meta: {\n      isTouched: boolean\n      isDirty: boolean\n      isValidating: boolean\n      errors: (string | { message?: string })[]\n    }\n  }\n  handleChange: (value: TValue) => void\n  handleBlur: () => void\n  pushValue?: (value: any) => void\n  removeValue?: (index: number) => void\n}\n\n/**\n * Hook to create a TanStack form with Zod validation\n * Returns a type-safe FormApi with inferred form data type\n *\n * @example\n * const form = useForm({\n *   schema: z.object({ email: z.string().email() }),\n *   defaultValues: { email: '' },\n *   onSubmit: async (values) => console.log(values),\n * })\n * // form is typed as FormApi<{ email: string }>\n */\nexport function useForm<TSchema extends z.ZodType>({\n  schema,\n  defaultValues,\n  onSubmit,\n  validationMode = \"onBlur\",\n}: {\n  schema: TSchema\n  defaultValues: z.infer<TSchema>\n  onSubmit: (values: z.infer<TSchema>) => void | Promise<void>\n  validationMode?: \"onChange\" | \"onBlur\" | \"onSubmit\"\n}): FormApi<z.infer<TSchema>> {\n  return useTanstackFormBase({\n    defaultValues,\n    validators: {\n      [validationMode]: schema,\n    },\n    onSubmit: async ({ value }) => {\n      await onSubmit(value as z.infer<TSchema>)\n    },\n  }) as unknown as FormApi<z.infer<TSchema>>\n}\n\n/**\n * Form wrapper component that provides form context and handles submission\n *\n * @example\n * <Form form={form}>\n *   <FormField form={form} name=\"email\">\n *     {(field) => (\n *       <FormItem field={field}>\n *         <FormLabel>Email</FormLabel>\n *         <FormControl>\n *           <Input\n *             value={field.state.value}\n *             onChange={(e) => field.handleChange(e.target.value)}\n *             onBlur={field.handleBlur}\n *           />\n *         </FormControl>\n *         <FormMessage />\n *       </FormItem>\n *     )}\n *   </FormField>\n * </Form>\n */\nexport function Form({\n  form,\n  children,\n  className,\n  disabled,\n  ...props\n}: {\n  form: FormApi\n  children: React.ReactNode\n  className?: string\n  disabled?: boolean\n} & Omit<React.ComponentProps<\"form\">, \"onSubmit\">) {\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault()\n        void form.handleSubmit()\n      }}\n      className={className}\n      {...props}\n    >\n      <fieldset\n        disabled={disabled ?? form.state.isSubmitting}\n        className={className}\n      >\n        {children}\n      </fieldset>\n    </form>\n  )\n}\n\n/**\n * Field wrapper component that connects to form and provides field API\n * Automatically infers form data type from the form parameter for type-safe field names!\n *\n * @example\n * const form = useForm({ schema: z.object({ email: z.string(), teamName: z.string() }), ... })\n *\n * <FormField form={form} name=\"email\"> // ✅ Valid - type automatically inferred!\n * <FormField form={form} name=\"teamName\"> // ✅ Valid - autocomplete works!\n * <FormField form={form} name=\"teamNam\"> // ❌ TypeScript error - typo caught at compile time!\n *\n * @example\n * // With arrays\n * const form = useForm({ schema: z.object({ users: z.array(z.object({ email: z.string() })) }), ... })\n * <FormField form={form} name=\"users\"> // ✅ Valid\n * <FormField form={form} name=\"users[0].email\"> // ✅ Valid - supports nested paths!\n */\nexport function FormField<\n  TForm extends FormApi,\n  TName extends DeepKeys<InferFormData<TForm>> = DeepKeys<InferFormData<TForm>>,\n>({\n  form,\n  name,\n  mode,\n  children,\n}: {\n  form: TForm\n  name: TName\n  mode?: \"value\" | \"array\"\n  children: (\n    field: FieldApiType<DeepValue<InferFormData<TForm>, TName>>\n  ) => React.ReactNode\n}) {\n  const FormFieldComponent = (form as any).Field\n  return (\n    <FormFieldComponent name={name} mode={mode}>\n      {children}\n    </FormFieldComponent>\n  )\n}\n\ntype FormItemContextValue = {\n  field: any\n  form: FormApi\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue | null>(null)\n\nconst useFormItem = () => {\n  const context = React.useContext(FormItemContext)\n\n  if (!context) {\n    throw new Error(\"FormItem components must be used within FormItem\")\n  }\n\n  return context\n}\n\n/**\n * Container for form field with error state and accessibility\n * Uses Field component from @/components/ui/field with TanStack Form integration\n *\n * @example\n * <FormItem field={field} form={form}>\n *   <FormLabel>Email</FormLabel>\n *   <FormControl>\n *     <Input {...getInputFieldProps(field)} />\n *   </FormControl>\n *   <FormDescription>Enter your email</FormDescription>\n *   <FormMessage />\n * </FormItem>\n */\nexport function FormItem({\n  field,\n  form,\n  className,\n  orientation,\n  children,\n  ...props\n}: {\n  field: any\n  form: FormApi\n  children: React.ReactNode\n  className?: string\n  orientation?: \"vertical\" | \"horizontal\" | \"responsive\"\n} & Omit<React.ComponentProps<typeof Field>, \"orientation\">) {\n  const id = React.useId()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  return (\n    <FormItemContext.Provider value={{ field, form, id }}>\n      <Field\n        data-invalid={isInvalid}\n        orientation={orientation}\n        className={className}\n        {...props}\n      >\n        {children}\n      </Field>\n    </FormItemContext.Provider>\n  )\n}\n\n/**\n * Label for form field - uses FieldLabel with TanStack Form integration\n */\nexport function FormLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof BaseFieldLabel>) {\n  const { field, form, id } = useFormItem()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  return (\n    <BaseFieldLabel\n      data-error={!!isInvalid}\n      className={cn(\"data-[error=true]:text-destructive\", className)}\n      htmlFor={`${id}-form-item`}\n      {...props}\n    />\n  )\n}\n\n/**\n * Control wrapper for form field input\n * Simply passes through children - field props should be spread directly on inputs\n */\nexport function FormControl({ children }: { children: React.ReactNode }) {\n  return <>{children}</>\n}\n\n/**\n * Description text for form field - uses FieldDescription with TanStack Form integration\n */\nexport function FormDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof BaseFieldDescription>) {\n  const { id } = useFormItem()\n\n  return (\n    <BaseFieldDescription\n      id={`${id}-form-item-description`}\n      className={className}\n      {...props}\n    />\n  )\n}\n\n/**\n * Error message for form field - uses FieldError with TanStack Form integration\n */\nexport function FormMessage({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof BaseFieldError>) {\n  const { field, form, id } = useFormItem()\n  const hasSubmitted = form.state.submissionAttempts > 0\n  const shouldShowError =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n\n  if (!shouldShowError && !children) {\n    return null\n  }\n\n  // Convert TanStack Form errors to the format expected by FieldError\n  const errors = shouldShowError\n    ? field.state.meta.errors.map((error: any) => {\n        if (typeof error === \"string\") {\n          return { message: error }\n        }\n        return error\n      })\n    : undefined\n\n  return (\n    <BaseFieldError\n      id={`${id}-form-item-message`}\n      errors={errors}\n      className={className}\n      {...props}\n    >\n      {children}\n    </BaseFieldError>\n  )\n}\n\n/**\n * Helper to get field state (isInvalid, errors, etc.)\n *\n * @example\n * const { isInvalid, errors } = getFieldState(field, form)\n */\nexport function getFieldState(field: any, form?: FormApi) {\n  const hasSubmitted = form ? form.state.submissionAttempts > 0 : false\n  const isInvalid =\n    hasSubmitted &&\n    field.state.meta.isTouched &&\n    field.state.meta.errors.length > 0\n  return {\n    isInvalid,\n    errors: field.state.meta.errors,\n    isTouched: field.state.meta.isTouched,\n    isDirty: field.state.meta.isDirty,\n    isValidating: field.state.meta.isValidating,\n  }\n}\n\n/**\n * Helper to get field props for native input elements (input, textarea)\n *\n * @example\n * <Input {...getInputFieldProps(field)} type=\"email\" />\n */\nexport function getInputFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value ?? \"\",\n    onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>\n      field.handleChange(e.target.value),\n    onBlur: field.handleBlur,\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for controlled components (Select)\n *\n * @example\n * <Select {...getControlledFieldProps(field)}>\n *   <SelectTrigger><SelectValue /></SelectTrigger>\n *   <SelectContent>...</SelectContent>\n * </Select>\n */\nexport function getControlledFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value,\n    onValueChange: (value: string) => field.handleChange(value),\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for checkbox components\n *\n * @example\n * <Checkbox {...getCheckboxFieldProps(field)} />\n */\nexport function getCheckboxFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    checked: field.state.value,\n    onCheckedChange: (checked: boolean) => {\n      field.handleChange(checked)\n      // Trigger blur to validate immediately after change\n      field.handleBlur()\n    },\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Helper to get field props for switch components\n *\n * @example\n * <Switch {...getSwitchFieldProps(field)} />\n */\nexport function getSwitchFieldProps(field: any) {\n  return getCheckboxFieldProps(field)\n}\n\n/**\n * Helper to get field props for textarea elements\n * Alias for getInputFieldProps since they share the same signature\n *\n * @example\n * <Textarea {...getTextareaFieldProps(field)} />\n */\nexport function getTextareaFieldProps(field: any) {\n  return getInputFieldProps(field)\n}\n\n/**\n * Helper to get field props for Select components\n * Alias for getControlledFieldProps with better naming for selects\n *\n * @example\n * <Select {...getSelectFieldProps(field)}>\n *   <SelectTrigger><SelectValue /></SelectTrigger>\n *   <SelectContent>...</SelectContent>\n * </Select>\n */\nexport function getSelectFieldProps(field: any) {\n  return getControlledFieldProps(field)\n}\n\n/**\n * Helper to get field props for RadioGroup components\n *\n * @example\n * <RadioGroup {...getRadioGroupFieldProps(field)}>\n *   <RadioGroupItem value=\"option1\" />\n *   <RadioGroupItem value=\"option2\" />\n * </RadioGroup>\n */\nexport function getRadioGroupFieldProps(field: any) {\n  const { isInvalid } = getFieldState(field)\n  return {\n    name: field.name,\n    value: field.state.value,\n    onValueChange: (value: string) => {\n      field.handleChange(value)\n      // Trigger blur to validate immediately after change\n      field.handleBlur()\n    },\n    \"aria-invalid\": isInvalid,\n  }\n}\n\n/**\n * Re-export Field components for direct use in custom layouts\n * These can be used when you need more control over the form layout\n * and don't need the TanStack Form context integration\n *\n * @example\n * // Direct usage without context\n * <FormField form={form} name=\"email\">\n *   {(field) => {\n *     const { isInvalid } = getFieldState(field, form)\n *     return (\n *       <Field data-invalid={isInvalid} orientation=\"horizontal\">\n *         <FieldLabel htmlFor=\"email\">Email</FieldLabel>\n *         <FieldContent>\n *           <Input {...getInputFieldProps(field)} id=\"email\" />\n *           <FieldDescription>Enter your email address</FieldDescription>\n *           <FieldError errors={field.state.meta.errors} />\n *         </FieldContent>\n *       </Field>\n *     )\n *   }}\n * </FormField>\n */\nexport {\n  Field,\n  FieldContent,\n  FieldGroup,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldTitle,\n}\n"
    },
    {
      "path": "components/ui/typography.tsx",
      "type": "registry:ui",
      "target": "",
      "content": "import type {\n  ComponentPropsWithoutRef,\n  ElementType,\n  PropsWithChildren,\n} from \"react\"\nimport type React from \"react\"\nimport type { VariantProps } from \"class-variance-authority\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype PolymorphicAsProp<E extends ElementType> = {\n  as?:\n    | E\n    | React.ComponentType<Omit<ComponentPropsWithoutRef<E>, \"as\">>\n    | React.FunctionComponent<Omit<ComponentPropsWithoutRef<E>, \"as\">>\n}\n\ntype PolymorphicProps<E extends ElementType> = PropsWithChildren<\n  Omit<ComponentPropsWithoutRef<E>, \"as\"> & PolymorphicAsProp<E>\n>\n\nconst typographyVariants = cva(\"\", {\n  variants: {\n    variant: {\n      h1: \"scroll-m-20 font-caption text-4xl font-extrabold tracking-tight lg:text-5xl\",\n      h2: \"scroll-m-20 text-xl font-semibold tracking-tight transition-colors md:text-2xl lg:text-3xl\",\n      h3: \"scroll-m-20 text-xl font-semibold tracking-tight\",\n      p: \"text-lg leading-7 not-first:mt-6\",\n      base: \"text-lg\",\n      quote: \"mt-6 border-l-2 pl-6 italic\",\n      code: \"relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold\",\n      lead: \"text-xl text-muted-foreground\",\n      large: \"font-semibold md:text-lg\",\n      small: \"text-sm font-medium leading-none\",\n      muted: \"text-sm text-muted-foreground\",\n      link: \"font-medium text-cyan-600 hover:underline dark:text-primary\",\n    },\n  },\n  defaultVariants: {\n    variant: \"p\",\n  },\n})\ntype TypographyCvaProps = VariantProps<typeof typographyVariants>\n\nconst defaultElement = \"base\"\n\nconst defaultElementMapping: Record<\n  NonNullable<TypographyCvaProps[\"variant\"]>,\n  ElementType\n> = {\n  h1: \"h1\",\n  h2: \"h2\",\n  h3: \"h3\",\n  p: \"p\",\n  quote: \"blockquote\" as \"p\",\n  code: \"code\",\n  lead: \"p\",\n  large: \"p\",\n  small: \"p\",\n  muted: \"p\",\n  link: \"a\",\n  base: \"p\",\n} as const\n\nexport function Typography<E extends ElementType = typeof defaultElement>({\n  as,\n  children,\n  className,\n  variant,\n  ...restProps\n}: PolymorphicProps<E> & TypographyCvaProps) {\n  const Component: ElementType =\n    as ?? defaultElementMapping[variant ?? \"base\"] ?? defaultElement\n\n  return (\n    <Component\n      {...(restProps as ComponentPropsWithoutRef<E>)}\n      className={cn(typographyVariants({ variant }), className)}\n      data-typography\n      data-typography-variant={variant}\n    >\n      {children}\n    </Component>\n  )\n}\n"
    }
  ]
}